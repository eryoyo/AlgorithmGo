//
// Created by eryo on 2021/8/31.
//

//最大公约数
/*
 gcd(a, b):如果b==0那么返回a, 否则返回gcd(b, a%b)
 */

//最小公倍数
/*
 lcm(a, b):两数乘积除以最大公约数
 */

//分数的四则运算
/*
 分数的表示：使用一个结构体，里面有两个元素表示分子和分母
 */
/*
 分数的化简：首先判断分母是否为负数如果为负数那么分子和分母同时取相反数
 然后判断分子是否为0，如果是那么取2分母为1
 最后将分子和分母同时除以最大公约数
 */
/*
 * 分数的四则运算
 */

//素数
/*
 素数筛法：构建一个素数表，其获取方式为从前向后遍历，
 如果没有被筛掉表示为素数，将该数的倍数全部标记为合数
 */

//质因数分解
/*
 任何一个整数都可以拆解成若干个质数的乘积，每一个质数可能出现多次
 首先创建一个结构体保存质数因子和出现的数量，
 用这个结构体创建一个长度为10的数组，因为int的范围有限，然后循环，
 判断当前的质数是不是因子，如果是就统计出现的次数，
 最后假如余数是零表示没有大于sqrt的质因子，否则有一个
 */

//大整数运算
/*
 大整数的表示：用一个结构体储存，结构体里面有一个数组，
 数组的每一个元素表示大数的每一位，其中还有一个元素表示大数的位数
 需要重写默认构造函数以对值进行预初始化
 大数的比较
 */
/*
 大数的加法：两个大数相加，从低位开始逐位相加，并加上产生的进位
 */
/*
 大数的减法：两个大数相减，从低位开始逐位相减，当不够减的时候向高位借一位
 */
/*
 大数的乘法：大数和普通数据类型整数相乘，将int型变量视为一个整体，然后逐位和大数相乘，
 乘得的结果模10得当前位，除10作为进位
 */
/*
 大数的除法：大数和低精度数字相除，商和被除数一一对应，从高位开始逐位相除，在过程中更新余数
 */

//扩展欧几里得算法，求ax+by=gcd(a, b)的一组解
/*
 推导过程见187-5.7小节  188-191
 首先可以看到最后求最小公约数的结果是当b=0时输出的，所以最后可以得到x=1,y=0的一组解，
 然后递归的求解知道求得最初的一个，可以看到是一组解，有确定的周期
 递归公式为x1=y2,y1=x2-(a/b)y2，求得解之后(x, y)解的周期分别为(b/gcd, a/gcd)
 */
/*
 求解ax+by=c的解，c是常数，已知ax+by=gcd(a, b)的一组解，那么只要c是gcd的倍数，此式子就有解
 只要等式两边都乘上c/gcd即可
 */
/*
 同余式的求解ax=c(mod m)
 可以将式子转化为ax-c=my, 也即ax+my=c的解，当c%gcd(a,m)==0的时候同余式有解，还有一点需要
 注意：因为有模运算，所以解不是无限个而是gcd个
 */
/*
 逆元：a和b的乘积模m为1，则称a和b互为模m的逆元
 (b*a)%m=((b%m)*(a%m))%m
 (b/a)%m=(b*c)%m=((b%m)*(c%m))%m,a,c互为逆元
 求a模m的逆元也就是求同余式ax=1(mod m)的解，有解的条件是a和m的最大公因数是1,gcd=1
 */
/*
 费马小定理：当m是素数且a不是m的倍数的时候可以得到a的m-1次方模m为1，即a的m-2次方是a的逆元
 */

//求n!中质因子的个数，例如求10!中质因子2的个数
/*
 当n < p的时候返回0
 推广为求n!中有多少个质因子p
 总共有n/p+n/(p^2)+n/(p^3)+...
 */

//计算组合数：表示从n个不同元素中选出m个元素的方案数-196
/*
 方法1：采用递归，变为不选最后一个数，从前n-1个数中选择m个数
 加上选最后一个数，从前n-1个数中选择m个数，边界为m=1或m=n时返回1
 */

//计算组合数模p
/*
 方法1：在递归方法的适当位置加上模p
 方法2：质因数分解之后对每一个质因数求模然后相乘
 */