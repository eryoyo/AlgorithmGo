//
// Created by eryo on 2021/9/5.
//

#include<algorithm>

using namespace std;

//算法思路
/*
 首先将点分为已访问的和暂未访问的
 每次都从未访问的点中挑选距离起点最近的点
 标记该点为已访问，并以该点为中介更新该点的相邻点
 更新的思路是假如使得该点距离起点的距离变小就更新该点
 */

//找到的最短路径可能有多条-加上第二标尺
/*
 给每条边增加一个边权
 给每个点增加一个点权
 问有多少条最短路径
 */
/*
 新增边权-增加一个花费数组-以边权代表花费为例
 边权数组-初始时起始点花费为0，其余为INF
 在未访问结点中找到一个距离最短的结点之后，更新相邻结点时
 假如使得距离更短，直接更新最短距离和此时的花费
 假如使得距离没有变化，但是使得花费更少了，更新花费
 */
/*
 新增点权-增加一个物资数组-以点权代表可以在该节点收集到的物资
 物资数组-初始时只有起点的物资为该点物资，其余点为0
 在未访问结点中找到一个距离最短的结点之后，更新相邻结点时
 假如使得距离更短，直接更新最短距离和此时收集到的物资
 假如使得距离没有变化，但是使得收集到的物资变多了，更新物资
 */
/*
 求最短路径条数-增加一个记录条数的数组
 记录条数的数组-初始时起点的数目为1，其余为0
 在未访问结点中找到一个距离最短的结点之后，更新相邻结点时
 假如使得距离更短，直接让该点继承前驱点的条数
 假如距离相同，让该点原来的条数加上此时前驱的条数
 */

const int MAXV = 1000;  //最大顶点数
const int INF = 1000000000;

int n;
int G[MAXV][MAXV];
int d[MAXV];        //起点到各个点的最短路径长度
int pre[MAXV];      //表示最短路径路上该点的前一个结点
bool vis[MAXV] = {false};

//求最短路径的长度
void Dijkstra_matrix(int s){
    fill(d, d + MAXV, INF);
    for(int i = 0; i < n; ++i){
        pre[i] = i;
    }
    d[s] = 0;
    for(int i = 0; i < n; ++i){
        int u = -1;
        int MIN = INF;
        //找到未访问结点中距离起点最小的
        for(int j = 0; j < n; ++j){
            if(!vis[j] && d[j] < MIN){
                u = j;
                MIN = d[j];
            }
        }
        //没有找到，表示不连通
        if(u == -1){
            return;
        }
        //标记该点为已访问，更新该点的邻居结点
        vis[u] = true;
        for(int v = 0; v < n; ++v){
            if(!vis[v] && G[u][v] != INF && d[u] + G[u][v] < d[v]){
                d[v] = d[u] + G[u][v];
                pre[v] = u;     //记录前驱
            }
        }
    }
}

